.np
AF4B-AF5D Prepare for RWTS call with a T/S List sector.
          Copy address of T/S List buffer to RWTS parmlist.
          Get track/sector of sector.
          Exit to caller.
.np
AF5E-AFDB Read a T/S List sector to file buffer.
          (CARRY flag is set at entry to indicate whether the
          first T/S List for the file is wanted (C=0) or the
          next (C=1).
          Memorize carry flag entry code.
          Checkpoint current T/S List sector if necessary.
          Set up for RWTS (AF4B).
          Select T/S List buffer (AF0C).
          Is first or next wanted?
          If first, go to AFB5 to continue.
          Otherwise, get link to next T/S List from this one.
          If link is non-zero, use it to find next one and go  
          to AFB5.
          Otherwise, we are out of T/S Lists for this file.
          If we are reading file, exit with error code.
          Otherwise, allocate a new sector (B244).
          Point old T/S List sector to new one's track/sector.
          Write old T/S List sector back to disk.
          Zero the buffer to form new T/S List sector.
          Compute and store the relative sector number of the
          first sector listed in this sector at +5,+6 into the
          buffer.
          Set RWTS opcode to write new T/S List sector to disk.
     AFB5 Set RWTS opcode to read old T/S List (unless we just
          allocated it above).
          Set track and sector and call RWTS to read old list
          or write new list.
          Compute relative sector number of last sector (plus
          one) in this list and store in workarea.
          Exit to caller with normal return code.
.np
AFDC-AFE3 Read a data sector.
          Set up for RWTS (AFE4).
          Set RWTS READ opcode and go to RWTS driver to do it.
.np
AFE4-AFF6 Prepare for RWTS with data sector.
          Copy address of data sector buffer to RWTS parmlist.
          Get its track/sector.
          And exit to caller.
.np
AFF7-B010 Read/write the VTOC buffer.
     AFF7 Read VTOC entry, go to AFFD.
     AFFB Write VTOC entry, fall through.
     AFFD Common code.
          Copy VTOC sector buffer address to RWTS parmlist.
          Get its track number and use sector $00.
          Exit through RWTS driver.
.np
B011-B036 Read a directory sector.
          (If CARRY flag is zero on entry, read first directory
          sector. If CARRY is one, read next)
          Memorize entry code.
          Set buffer pointers (B045).
          First or next?
          If first, get track/sector of directory sector from
          VTOC at offset +1,+2.
          Otherwise, get track/sector from directory sector at
          offset +1,+2. If track is zero, exit with error code
          (end of directory).
          Call RWTS to read sector.
          Exit with normal return code.
.np
B037-B044 Write directory sector.
          Set buffer pointers.
          Find its track/sector in workarea.
          Exit through RWTS to write it.
.np
B045-B051 Prepare for RWTS for directory buffer.
          Copy directory buffer address to RWTS parmlist.
          Exit to caller.
.np
B052-B0B3 Read/Write Track/Sector (RWTS) driver.
          Set track/sector in RWTS parmlist.
     B058 Set command code (read,write,etc.)
          If writing, set flag (B5D5).
          Set volume number expected in parmlist.
          Set slot*16 in parmlist.
          Set drive in parmlist.
          Set sector size in parmlist.
          Set IOB type in parmlist ($01).
          Call RWTS, passing parmlist pointer.
          Copy true volume found to file manager parmlist.
          Reset volume expected field in RWTS parmlist.
          If an error did not occur, exit to caller.
          Otherwise, get return code.
          Translate vol mismatch to rc=7, write protected to
          rc=4 and all other errors to rc=8 (I/O error).
          Exit file manager now.
.np
B0B6-B133 Read next data sector (if necessary).
          Is the current file position in the current data
          sector now in memory?
          If so, go to B12C.
          Otherwise, checkpoint data sector buffer.
          Is the current file position prior to or after this
          T/S List's domain?
          If not, go to B0F3.
          Otherwise, read each T/S List for the file, starting
          with the first, until the proper one is found.
          If it is never found, exit with error (ran off end of
          file reading).
     B0F3 Data is in this T/S List sector.
          Compute the displacement to the proper entry in this
          T/S List sector.
          Select the T/S List buffer.
          Get the track of the data sector wanted.
          If non-zero, go to B114.
          Otherwise, if not writing, exit with error (no data
          to read there).
          If writing, allocate a new sector and store its 
          track/sector location in the list at this point
          (B134).
          Go to B120.
     B114 Read old data sector, using the track/sector found
          in the T/S List entry.
     B120 Save number of sector last read in workarea.
     B12C Select data buffer.
          Get byte offset and exit normally to caller.
.np
B134-B15A Add a new data sector to file.
          Allocate a sector (B244).
          Put track/sector numbers in T/S List entry.
          Select data buffer and zero it.
          Set flags to indicate that the T/S List sector and
          the data sector buffer require checkpoints.
          Exit to caller.
.np
B15B-B193 Increment record number and byte offset into file.
          Copy current record number and byte offset to file
          manager parameter list to pass back to caller.
          Increment byte offset in workarea.
          If byte offset equals record length, set byte offset
          back to zero and increment record number.
          Return to caller.
.np
B194-B1A1 Increment file position offset.
          Increment byte offset into current sector by one.
          If at end of sector, increment sector number by one.
          Return to caller.
.np
B1A2-B1B4 Copy and advance range address.
          Copy range address from file manager parmlist to $42.
          Increment range address in parmlist for next time
          through.
          Return to caller.
.np
B1B5-B1C8 Decrement range length.
          Decrement range length in file manager parmlist by
          one.
          If zero, exit file manager.
          Otherwise, exit to caller.
.np
B1C9-B21B Locate or allocate a directory entry in the catalog.
          Read the VTOC sector (AFF7).
          Set $42,$43 to point to file name we are looking for.
          Set pass number to one (locate file).
     B1D8 Initialize directory sector offset (first sector).
     B1E1 Increment sector offset.
          Read directory sector.
          If at end of directory, go to B23A.
          Set entry index to first file entry.
     B1EB Get track.
          If deleted, skip entry, go to B217.
          If empty, end of directory, go to B212.
          Advance index to filename in directory.
          Compare against filename wanted.
          If they match, return entry index and exit.
          If not, advance index to next entry in sector and
          loop back to B1EB.
          If at end of sector, go to B1E1 to get next sector.
     B212 If pass number is one, go to B1D8 to start second
          pass.
     B217 If pass number is one, go to B20B to skip entry.
          If second pass, fall through to allocate entry.
.np
B21C-B22F Copy file name to directory entry.
          Advance index to file name field in directory entry.
          Copy 30 byte filename to directory entry.
          Reload directory index and return to caller.
.np
B230-B239 Advance index to next directory entry in sector.
          Add 35 (length of entry) to index.
          Test for end of sector and return to caller.
.np
B23A-B243 Switch to second pass in directory scan.
          If on pass one, switch to pass 2 and go to B1D8.
          If on pass two, exit file manager with "DISK FULL"
          error.
.np
B244-B2C2 Allocate a disk sector.
          Is there a track currently allocated to this file?
          If not, go to B26A to find a track with free sectors.
     B249 Otherwise, decrement sector number to get next 
          possible free sector number.
          If there are no more sectors on this track, go to
          B265 to find a new track.
          Otherwise, rotate the track bit mask by one position
          and get the bit for this sector.
          If the sector is in use, loop back to B249.
          Otherwise, add one to file's sector count.
          Pass back sector number (track number is at B5F1).
          And return to caller.
     B265 Indicate no track is being used at present.
     B26A Reset allocation flag to allow at least one complete
          search of all tracks for some space.
          Read VTOC sector.
     B272 Get last track allocated from and add direction value
          to get next track to examine (+1 or -1).
          Are we back to track 0?
          If so, go to B284.
          Otherwise, are we past track 34?
          If so, reverse direction and go to B28E.
     B284 Is this the second time we have come to track 0 ?
          (check allocation flag).
          If so, exit with "DISK FULL" error.
          Otherwise, set allocation flag to remember this.
          Set direction to forward (+1).
     B28E Begin at directory track (17 + or - 1).
          Compute bit map index (tracknumber*4).
          Copy track bit map from VTOC to workarea, watching
          to see if all four bytes are zero (track is full).
          In any case, set all four bytes in VTOC to zero 
          (allocate all sectors).
          If no free sectors in the track, go to B272 to try
          next track.
          Otherwise, write VTOC to disk to insure file's
          integrity.
          Set sector number to last sector in track.
          Go to B249 to allocate one of its free sectors to
          the file.
.np
B2C3-B2DC Release pre-allocated sectors in current track and
          checkpoint the VTOC.
          Has a track been allocated to the file?
          If not, exit to caller.
          Otherwise, read VTOC.
          Get next sector which could have been used (number
          of times track map was shifted during allocation).
          Call B2DD to shift track bit map back and merge it
          back into the VTOC bit map.
          Indicate no track has been allocated.
          Exit to caller.
.np
B2DD-B2FF Free one or more sectors by shifting mask in file
          manager's allocation area back into VTOC bit map.
          (If CARRY is set, current sector is freed also)
          Rotate entire 4 byte track bit mask once.
          Repeat for as many sectors as were allocated.
          Compute index into VTOC for this track's map.
          If zero, exit.
          Merge ("OR") file manager's bits with those already
          in VTOC, freeing sectors which were never used by
          the file.
          Return to caller.
.np
B300-B35E Calculate file position.
          Set record number passed in file manager parmlist
          in workarea and in sector offsets.
          Clear sector offset high part.
          Perform a 16 bit multiply as follows:
          3 byte file position = record number times record
          length.
          Add the byte offset from the parmlist into the three
          byte file position value (B5E4,B5E5,B5E6).
          Return to caller.
.np
B35F-B37D Error exits.
     B35F RC=1 "LANGUAGE NOT AVAILABLE"
     B363 RC=2 "RANGE ERROR" (bad opcode)
     B367 RC=3 "RANGE ERROR" (bad subcode)
     B36B RC=4 "WRITE PROTECTED"
     B36F RC=5 "END OF DATA"
     B373 RC=6 "FILE NOT FOUND"
     B377 RC=9 "DISK FULL" (all files closed)
     B37B RC=A "FILE LOCKED"
.np
B37F-B396 Exit file manager.
     B37F Exit with no errors.
          Get return code of zero.
          Clear carry flag and go to B386.
     B385 Set carry flag to indicate error.
     B386 Save return code in parmlist.
          Clear monitor status register ($48) after RWTS has
          probably tromped on it.
          Save file manager workarea to file buffer (AE7E).
          Restore processor status and stack register.
          Exit to original caller of file manager.
.np
B397-B3A3 File manager scratch space.
     B397 Track/sector of current directory sector (2 bytes).
     B39B S register save area.
     B39C Directory index.
     B39D Catalog line counter/Directory lookup flag/Etc.
     B39E LOCK/UNLOCK mask/Allocation flag/Etc.
     B3A0 Four byte mask used by INIT to free an entire track
          in the VTOC bit map.
.np
B3A4-B3A6 Decimal conversion table (1,10,100).
.np
B3A7-B3AE File type name table used by CATALOG.
          File types are: T,I,A,B,S,R,A,B, corresponding to
          hex values: $00, $01, $02, $04, $08, $10, $20, and
          $40 respectively.
.np
B3AF-B3BA ASCII text "DISK VOLUME " backwards. Used by CATALOG.
.np
B3BB-B4BA VTOC sector buffer.
     B3BC Track/sector of first directory sector.
     B3BE DOS release number (1, 2, or 3).
     B3C1 Volume number of diskette.
     B3E2 Number of entries in each T/S List sector.
     B3EB Track to allocate next.
     B3EC Direction of track allocation (+1 or -1)
     B3EF Number of tracks on a disk.
     B3F0 Number of sectors on a disk.
     B3F1 Sector size in bytes (2 bytes)
     B3F3 Track 0 bit map
     B3F7 Track 1 bit map
          etc.
     B47B Track 34 bit map
.np
B4BB-B5BA DIRECTORY sector buffer.
     B4BC Track/sector of next directory sector.
     B4C6 First directory entry and
          Track of T/S List
     B4C7 Sector of T/S List
     B4C8 File type and lock bit
     B4C9 Filename field (30 bytes)
     B4E7 Size of file in sectors (including T/S List(s)).
.np
B5BB-B5D0 File manager parameter list.
     B5BB Opcode
     B5BC Subcode
     B5BD Eight bytes of variable parameters depending on 
          opcode.
     B5C5 Return code.
     B5C7 Address of file manager workarea buffer.
     B5C9 Address of T/S List sector buffer.
     B5CB Address of data sector buffer.
     B5CD Address of next DOS buffer on chain (not used).
.np
B5D1-B5FD File manager workarea.
     B5D1 1st T/S List sector's track/sector.
     B5D3 Current T/S List sector's track/sector.
     B5D5 Flags: 80=T/S List needs checkpoint
                 40=Data sector needs checkpoint
                 20=VTOC sector needs checkpoint
                 02=Last operation was write
     B5D6 Current data sector's track/sector.
     B5D8 Directory sector index for file entry.
     B5D9 Index into directory sector to directory entry for
          file.
     B5DA Number of sectors described by one T/S List.
     B5DC Relative sector number of first sector in list.
     B5DE Relative sector number +1 of last sector in list.
     B5E0 Relative sector number of last sector read.
     B5E2 Sector length in bytes.
     B5E4 File position (3 bytes) sector offset, byte offset
          into that sector.
     B5E8 Record length from OPEN.
     B5EA Record number.
     B5EC Byte offset into record.
     B5EE Number of sectors in file.
     B5F0 Sector allocation area (6 bytes).
          Next sector to allocate (shift count)
          Track being allocated
          Four byte bit map of track being allocated, rotated
          to next sector to allocate.
     B5F6 File type.
     B5F7 Slot number times 16.
     B5F8 Drive number.
     B5F9 Volume number (complemented).
     B5FA Track number.
.np
B5FE-B5FF Not used.
.np
B600-B6FF Start of Boot 2/RWTS image.
     B600 Boot 1 image which can be written to INITed disks
          on track 0, sector 0.
     B65D DOS 3.3 patch area.
     B65D APPEND patch flag.
     B65E APPEND patch. Come here when file manager driver 
          gets an error other than end of data.
          Locate and free the file buffer.
          Clear the APPEND flag.
          Get the error number and go print error (A6D2).
     B671 APPEND patch. Come here from APPEND command handler
          to increment record number if APPEND flag is set and
          to clear the flag. Exit through POSITION.
     B686 VERIFY patch. Come here from I/O a range of bytes
          routine to exit through VERIFY after SAVE or BSAVE.
     B692 APPEND patch. Come here from file manager driver if
          return code was END OF DATA.
          Test the file position for zero.
          If non-zero, set APPEND flag on and return to caller.
          If zero (at start of file), copy record number and
          byte offset to file manager parmlist and return a
          zero data byte to caller.
     B6FE Page address of first page in Boot 2.
     B6FF Number of sectors (pages) in Boot 2.
.br
.nx ch8.7
